	uboot_uptodate () {
		(
			. /usr/lib/ubit/bootloader

			_addr=${_ADDR}
			_dev=${_DEV}

			match=`( _valid /usr/share/ubit/original ) || ( _valid /usr/share/ubit/firmware )`	
			if [ "${match}" ]; then
				echo Existing firmware identified as matching: $match 
				_image="${match%%.*}.kwb"
				_checksum
				if (_verify); then
					echo The installed firmware is already up-to-date
				else
					echo Writing latest ${match%%.*} firmware to ${_DEV}
					_write
					( _valid /usr/share/ubit/firmware )
					_verify_correct
				fi
			else
				echo The existing firmware cannot be identified, so no update has been performed.
			fi
		)
	}

	uboot_chain () {
		(
			. /usr/lib/ubit/bootloader

			# sets up a u-boot image in a section of NAND memory in order to allow chain booting
			_image="$1"
			_addr=${_CHAIN_ADDR}
			_dev=${_CHAIN_DEV}

			echo UBIT.CHAIN:$1
			if [ -e "${_image}" ]; then 
				echo UBIT.CHAIN:${_image} writing to ${_addr} of ${_dev}

				_checksum
				_write
				( _verify )
			fi
		)
	}

	uboot_revert () {
		(
			. /usr/lib/ubit/bootloader

			_addr=${_CHAIN_ADDR}
			_dev=${_CHAIN_DEV}

			if ( _valid /usr/share/ubit/original ); then 
				( cd /tmp

					_image=$( _backup )
					_addr=0
					_dev=${_DEV}

					_checksum
					_write
					( _valid /usr/share/ubit/original )
					_verify_correct
				)
			fi
		)
	}

	uboot_install () {
		(
			. /usr/lib/ubit/bootloader

			_image="/usr/share/ubit/firmware/$1"
			_addr=${_ADDR}
			_dev=${_DEV}

			_checksum
			if [ -e "${_image}" ] && ! ( _verify ) ; then

				statusled active
				echo UBIT:bl: backing up ${_dev} to $(_backup)
				echo Keep your u-boot backups safe.
				_write
				statusled idle
				_verify_correct

			fi
		)
	}

