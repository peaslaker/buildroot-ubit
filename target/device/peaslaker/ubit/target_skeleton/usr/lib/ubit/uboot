	uboot_uptodate () {
		(
			. /usr/lib/ubit/bootloader

			_addr=${_ADDR}
			_dev=${_DEV}

			if match=`( _identify /usr/share/ubit/original ) || ( _identify /usr/share/ubit/firmware )`; then	
				echo Existing firmware identified as matching: $match 
				match="${match##*/}"
				_image="/usr/share/ubit/firmware/${match%%.*}.kwb"
				if (_image_verify); then
					echo The installed firmware is already up-to-date
				else
					echo Writing latest ${match%%.*} firmware to ${_DEV}
					_write_checksum
					_write
					_write_verify_correct
				fi
			else
				echo The existing firmware cannot be identified, so no update has been performed.
			fi
		)
	}

	uboot_chain () {
		(
			. /usr/lib/ubit/bootloader

			# sets up a u-boot image in a section of NAND memory in order to allow chain booting
			_image="$1"
			_addr=${_CHAIN_ADDR}
			_dev=${_CHAIN_DEV}

			echo UBIT.CHAIN:$1
			if [ -e "${_image}" ]; then 
				echo UBIT.CHAIN:${_image} writing to ${_addr} of ${_dev}

				_write_checksum
				_write
				( _write_verify )
			fi
		)
	}

	uboot_revert () {
		(
			. /usr/lib/ubit/bootloader

			_addr=${_CHAIN_ADDR}
			_dev=${_CHAIN_DEV}

			if ( _identify /usr/share/ubit/original ); then 
				( cd /tmp

					_image=$( _backup )
					_addr=0
					_dev=${_DEV}

					_write_checksum
					_write
					_write_verify_correct
				)
			fi
		)
	}

	uboot_install () {
		(
			. /usr/lib/ubit/bootloader

			_image="/usr/share/ubit/firmware/$1.kwb"
			_addr=${_ADDR}
			_dev=${_DEV}

			if [ -e "${_image}" ] && ! ( _image_verify ) ; then
				statusled active
				echo UBIT:bl: backing up ${_dev} to $(_backup)
				echo Keep your u-boot backups safe.
				_write_checksum
				_write
				statusled idle
				_write_verify_correct

			fi
		)
	}

