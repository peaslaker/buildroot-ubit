	_copy_bootable_uimage () {
		( ubinfo -d 0 -N boot &>/dev/null ) && {
			mkdir -p /tmp/boot ${OUTDIR}boot
			mount -t ubifs ubi:boot /tmp/boot -o ro
			cat /tmp/boot/boot/uImage > "${OUTDIR}boot/uImage"
			umount /tmp/boot
		}
	}

	set_install () {
		{	echo ubiformat_mtd3
			echo flash_once
		} 	> "${OUTDIR}.ubit.once"
		cat "${OUTDIR}.ubit/uInstaller" > "${OUTDIR}uInitrd"
		_copy_bootable_uimage
	}

	set_install_rw () {
		{	echo ubiformat_mtd3
			echo flash_once
			echo mkrw
		} 	> "${OUTDIR}.ubit.once"
		cat "${OUTDIR}.ubit/uInstaller" > "${OUTDIR}uInitrd"
		_copy_bootable_uimage
	}

	template () {
		if [ "$1" ]; then
			[ -e "/etc/ubit/targets.$1" ] && cat "/etc/ubit/targets.$1" > /etc/ubit/targets
		else
			cat /etc/ubit/targets.default > /etc/ubit/targets
		fi
	}

	_ubit_ubimg () {
		lebcnt=$1
	
		echo UBIT.UBIMG:$prt:trying mkfs.ubifs in $lebcnt LEBs...
		while true; do
			mkfserror=`mkfs.ubifs -r ${prt} -m 2048 -e 129024 -c $lebcnt -o ${prt}.ubimg 2>&1 1> /dev/null` 
			if [ "$?" -eq "0" ] ; then
				echo $pth $prt $lebcnt  >> /etc/ubit/images
				exit 0
			elif [ "${mkfserror%% (*}" = "Error: max_leb_cnt too low" ]; then
				echo UBIT.UBIMG:$prt:$mkfserror
				mkfserror=${mkfserror##*(}
				lebcnt=${mkfserror%% *}
				echo UBIT.UBIMG:$prt:retrying mkfs.ubifs in $lebcnt LEBs...
			else
				echo UBIT.UBIMG:$prt:unknown error creating .ubimg:$lebcnt
				echo UBIT.UBIMG:$prt:$mkfserror
				exit 1
			fi
		done
	}

	ready_prepared () {
		cat .ubit/images > /etc/ubit/images
		cat .ubit/extramounts > /etc/ubit/extramounts
		cat .ubit/ubimounts > /etc/ubit/ubimounts
		touch /etc/ubit/images
		touch /etc/ubit/extramounts
		touch /etc/ubit/ubimounts

		# this odd twist sets the ramdisk contents after the scan has completed but before the writes begin
		mkdir -p .ubit/ramdisk
		cat /etc/ubit/cpio_list | cpio -H newc -o | gzip > /tmp/initramfs.cpio.gz
		mkimage -A arm -O linux -T ramdisk -C gzip -a 0x0 -e 0x0 -n "Installed: `cat /etc/issue`" -d /tmp/initramfs.cpio.gz .ubit/ramdisk/uInitrd

		(  	cd .ubit
			pth=.ubit
			prt=ramdisk
		 	_ubit_ubimg 32
		)

		cat /etc/ubit/cpio_list | cpio -H newc -o | gzip > /tmp/initramfs.cpio.gz
		mkimage -A arm -O linux -T ramdisk -C gzip -a 0x0 -e 0x0 -n "Installer: `cat /etc/issue`" -d /tmp/initramfs.cpio.gz .ubit/uInstaller
	}

	_ubit_scan () {

		# by the time we get here, there will be:
		# - some sort of filesystem image available for analysis mounted on .ubit/rootfs
		# - a populated targs variable listing the work to be done

		uni="$@"
		echo $uni

		statusled active

		rm /tmp/.scanimages
		rm /etc/ubit/images
		rm /etc/ubit/extramounts
		rm /etc/ubit/ubimounts
		touch /etc/ubit/images
		touch /etc/ubit/extramounts
		touch /etc/ubit/ubimounts

		sort -r /tmp/targets | while true; do 
			read pth prt ubiprt
			if [ "$?" -eq "0" ] ; then
				if [ "${prt}" = "" ]; then
					echo UBIT.SCAN:${pth}, leaving a stub
					mkdir -p .ubit/rootfs/${pth}
					rm -rf .ubit/rootfs/${pth}/*
				elif [ "${prt}" = "tmpfs" ]; then
					echo UBIT.SCAN:${pth}, leaving a stub for tmpfs mount
					mkdir -p .ubit/rootfs/${pth}
					rm -rf .ubit/rootfs/${pth}/*
					echo mount -t tmpfs none $pth >> /etc/ubit/extramounts
				elif [ "${prt}" = "ubi" ]; then
					prt=${ubiprt}
					echo UBIT.SCAN:${pth}, moved to staging area for ubi vol ${prt} 
					uni="${uni} ${prt}"
					mkdir -p .ubit/${prt}/${pth}
					mv .ubit/rootfs/${pth}/* .ubit/${prt}/${pth}
					rm -rf .ubit/rootfs/${pth}
				else
					echo UBIT.SCAN:${pth}, moved archive area .prt/${prt}
					mkdir -p .prt/${prt}/${pth}
					mv .ubit/rootfs/${pth}/* .prt/${prt}/${pth}
					rm -rf .ubit/rootfs/${pth}
				fi
			else
				echo UBIT.SCAN:all targets read, now processing ubi target volumes...
				echo First attempt for each volume tries with a small maximum LEB count which may fail, but the error 
				echo tells us the number of LEBs to retry.  It takes a bit of time and sometimes it misses
				echo by 1, and has to retry a third time.  It is reliable though.  Normal operation involves
				echo error messages for each failed attempt, including segmentation faults.
				echo
				for prt in `echo ${uni} | tr " " "\n" | sort -ur` ; do
					echo UBIT.SCAN:processing ubi target volume: ${prt}
					case ${prt} in
					boot)
						mkdir -p .ubit/boot/boot
						[ -e boot.tar.gz ] && tar -C .ubit/boot/boot -xzf boot.tar.gz 
						echo .ubit/boot $prt 32 >> /tmp/.scanimages
						;;
					ramdisk)
						# this noop means that the ramdisk ubimg only gets created by the 'ready_prepared' function
						;;
					modules)
						mkdir -p .ubit/modules
						[ -e modules.tar.gz ] && tar -C .ubit/modules -xzf modules.tar.gz
						echo .ubit $prt 32 >> /tmp/.scanimages
						;;
					rootfs)
						mkdir -p .ubit/rootfs
						echo .ubit $prt 32 >> /tmp/.scanimages
						;;
					*)
						echo .ubit $prt 32 >> /tmp/.scanimages
						echo $prt >> /etc/ubit/ubimounts
						;;
					esac
				done

				statusled progress

				# now we write all the images
				cat /tmp/.scanimages | while read pth prt lebcnt; do
					( cd $pth
						_ubit_ubimg $lebcnt
					)
				done
				cat /etc/ubit/images > .ubit/images
				cat /etc/ubit/extramounts > .ubit/extramounts
				cat /etc/ubit/ubimounts > .ubit/ubimounts
				break
			fi

		done
		statusled busy
	}

	_ubit_password () {
		[ "$1" ] && {
			echo setting password
			echo $1 | md5sum > /etc/ubit/password
		}
	}

	kernel () {
		cat /etc/ubit/targets.kernel > /tmp/targets

		statusled progress

		echo UBIT.KERNEL:purging old work environment...
		rm -rf "${OUTDIR}.ubit"
		mkdir -p "${OUTDIR}.ubit/boot" "${OUTDIR}.ubit/rootfs"

		# this is a little bit hard coded
		echo UBIT.KERNEL:extracting boot...
		tar -c boot  | tar -C "${OUTDIR}.ubit/rootfs" -x 
		tar -c lib/modules   | tar -C "${OUTDIR}.ubit/rootfs" -x 

		(
			[ "${OUTDIR}" ] && cd "${OUTDIR}"
			_ubit_scan boot modules
		)
		statusled idle
	}


	is_prepared () {
		[ -e .ubit/images ] && [ -e .ubit/ubimounts ] && [ -e .ubit/extramounts ] && exit 0
		exit 1  
	}

	prepare () {
		_ubit_password "$1"

		if [ -e .ubit.targets ]; then
			cat .ubit.targets > /tmp/targets
		else
			cat /etc/ubit/targets > /tmp/targets	
		fi

		statusled progress	# this is about to take a long time

		echo UBIT.PREPARE:purging old work environment...
		rm -rf "${OUTDIR}.ubit" "${OUTDIR}.prt"
		mkdir -p "${OUTDIR}.ubit/rootfs" "${OUTDIR}.prt"

		echo UBIT.PREPARE:extracting rootfs...
		( tar -C "${OUTDIR}.ubit/rootfs" -xf rootfs.tar ||  
		tar -C "${OUTDIR}.ubit/rootfs" -xzf rootfs.tar.gz ) && ( 
			[ "${OUTDIR}" ] && cd "${OUTDIR}"
			_ubit_scan boot modules rootfs
			ready_prepared

		)
		statusled idle
	}

