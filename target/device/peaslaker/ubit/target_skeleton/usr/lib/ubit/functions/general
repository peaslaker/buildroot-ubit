# usage function
	usage () {
		echo "The following special macro instructions are supported by the UBIT ramdisk."
		echo
		echo Install preparation macros
		echo "     - on [device] [macro] # specify a block device other than /dev/sda1 to be used as the working area for the command"
		echo "     - to [device] [macro] # specify a block device other than /dev/sda1 to be used as the output area for the command"
		echo "     - template <targets>  # copy one of the pre-defined targets files into the root filesystem to be used for the scan and generation of UBIFS images"
		echo "     - snapshot [password] # creates ubifs images and matched installer ramdisk from a snapshot of the normal mountable running system"
		echo "     - prepare [password]  # creates ubifs images and matched installer ramdisk from rootfs.tar.gz (optionally rootfs.tar), modules.tar.gz and boot.tar.gz"
		echo "     - kernel              # partition the contents of a boot.tar.gz and modules.tar.gs onto ubifs partitions"
		echo "     - install             # sets ubifs images and matched installer ready for use once"
		echo "     - install_rw          # sets ubifs images and matched installer ready for use once"
		echo "     - set_install         # sets ubifs images and matched installer ready for repeated use"
		echo "     - set_install_rw      # sets ubifs images and matched installer ready for repeated use"
		echo
		echo "Install execution macros (need to be run by ramdisk launched from external install media)"
		echo "     - ubiformat_mtd3    # format mtd3 as a ubi partition"
		echo "     - ubiattach_mtd3    # attach mtd3 as a ubi partition"
		echo "     - mkrw              # creates a rw UBIFS partition using all remaining available logical erase blocks "
		echo "     - rmrw              # delete a preexisting rw UBIFS partition"
		echo "     - flash             # flash writes ubifs images - dismantles installer environment after use"
		echo
		echo "Firmware installation macros"
		echo "     - dockstar     # install original dockstar u-boot as chain u-boot on mtd1"
		echo "     - goflexnet    # install original goflexnet u-boot as chain u-boot on mtd1"
		echo "     - revert       # revert to pogoplug; using previously installed chain u-boot"
		echo
		echo "Boot sequence adjustments"
		echo "     - nc_off    # switch U-Boot network console off"
		echo "     - nc_on     # switch U-Boot network console on (default 10.10.10.5)" 
		echo "     - ubiargs_default   # switch U-Boot read-write partition priority to defaults" 
		echo "     - ubiargs_tmpfs     # switch U-Boot to use a tmpfs read/write partition" 
		echo "     - boot_fast          # switches off boot from UBIFS as the default, allowing boot from HD and USB (sda, default rootfs)"
		echo "     - boot_normal            # switches on boot from UBIFS as the default"
		echo "     - ethaddr           # sets the 'ethaddr' variable in the bootloader environment.  Mac address will change at random unless forced"
		echo 
		echo "If a password has been set on the ramdisk, every command must be prefixed with the correct password."
		echo 
		echo Generally, the Orange LED is used to signal the degree of activity.  
		echo For example in the install process, when the script is actively scanning
		echo the source material, the orange LED should flash fast.  When it is engaged
		echo in the big atomic commands for echo creating UBIFS images, it flashes slowly.
		echo When it is at a prompt, the green heartbeat is healthy, the orange heartbeat 
		echo indicates a need to intervene before rebooting because you have a brick on 
		echo your hands.
		echo 
		}

        status_value () {
                param=$1
                value=$2
		set - `ls -d /sys/class/leds/status\:*\:${func}`
		ctl="$1/${param}"
                if ! [ -e "${ctl}" ]; then
			set - `ls -d /sys/class/leds/status\:*`
			ctl="$1/${param}"
		fi
                if [ -e "${ctl}" ]; then
			echo "$value" > "$ctl"
		fi
        }

        status_trigger () {
                status_value trigger "$1"
        }

        status_off () {
                func=$1
                status_trigger off
        }

        status_on () {
                func=$1
                status_trigger default-on
        }

        status_heartbeat () {
                func=$1
                status_trigger heartbeat
        }

        status_flash () {
                func=$1
                status_trigger timer
                status_value delay_off 100
                status_value delay_on 100
        }

        status_blink () {
                func=$1
                status_trigger timer
                status_value delay_off 100
                status_value delay_on 10
        }

        status_blink () {
                func=$1
                status_trigger timer
                status_value delay_off 100
                status_value delay_on 1000
        }

        health_off () {
                status_off health
        }

        fault_off () {
                status_off fault
        }

        health_on () {
                status_on health
        }

        fault_on () {
                status_on fault
	}

        health_heartbeat () {
                status_heartbeat health
        }

        fault_heartbeat () {
                status_heartbeat fault
	}

        health_flash () {
                status_flash health
        }

        fault_flash () {
                status_flash fault
	}

        health_blink () {
                status_blink health
        }

        fault_blink () {
                status_blink fault
	}

        health_pulse () {
                status_pulse health
        }

        fault_pulse () {
                status_pulse fault
	}

