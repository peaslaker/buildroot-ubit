# by the time we get here, there will be:
# 		- some sort of filesystem image available for analysis mounted on .ubit/rootfs
#		- a populated targs variable listing the work to be done
#		- optionally a suffix variable defined for backing up old ubi partitions

	orange_fast

	rm /tmp/.scanimages
	rm /.ubit.images
	rm /.ubit.extramounts
	rm /.ubit.ubimounts
	rm /.ubit.rename
	touch /.ubit.images
	touch /.ubit.extramounts
	touch /.ubit.ubimounts
	touch /.ubit.rename

	rm .ubit.images
	sort -r $targs | while true; do 
		read pth prt ubiprt
		if [ "$?" -eq "0" ] ; then
			if [ "${prt}" = "" ]; then
				echo UBIT.SCAN:${pth}, leaving a stub
				mkdir -p .ubit/rootfs/${pth}
				rm -rf .ubit/rootfs/${pth}/*
			elif [ "${prt}" = "tmpfs" ]; then
				echo UBIT.SCAN:${pth}, leaving a stub for tmpfs mount
				mkdir -p .ubit/rootfs/${pth}
				rm -rf .ubit/rootfs/${pth}/*
				echo mount -t tmpfs none $pth >> /.ubit.extramounts
			elif [ "${prt}" = "ubi" ]; then
				prt=${ubiprt}
				echo UBIT.SCAN:${pth}, moved to staging area for ubi vol ${prt} 
				uni="${uni} ${prt}"
				mkdir -p .ubit/${prt}/${pth}
				mv .ubit/rootfs/${pth}/* .ubit/${prt}/${pth}
				rm -rf .ubit/rootfs/${pth}
			else
				echo UBIT.SCAN:${pth}, moved archive area .prt/${prt}
				mkdir -p .prt/${prt}/${pth}
				mv .ubit/rootfs/${pth}/* .prt/${prt}/${pth}
				rm -rf .ubit/rootfs/${pth}
			fi
		else
			echo UBIT.SCAN:all targets read, now processing ubi target volumes...
			echo First attempt for each volume tries with a small maximum LEB count which may fail, but the error 
			echo tells us the number of LEBs to retry.  It takes a bit of time and sometimes it misses
			echo by 1, and has to retry a third time.  It is reliable though.  Normal operation involves
			echo error messages for each failed attempt, including segmentation faults.
			echo
			for prt in `echo ${uni} | tr " " "\n" | sort -ur` ; do
				echo UBIT.SCAN:processing ubi target volume: ${prt}
				case ${prt} in
				boot)
					mkdir -p .ubit/boot/boot
					[ -e boot.tar.gz ] && tar -C .ubit/boot/boot -xzf boot.tar.gz 
					echo .ubit/boot $prt 32 >> /tmp/.scanimages
					;;
				ramdisk)
					echo .ubit $prt 32 >> /tmp/.scanimages
					;;
				modules)
					mkdir -p .ubit/modules
					[ -e modules.tar.gz ] && tar -C .ubit/modules -xzf modules.tar.gz
					echo .ubit $prt 32 >> /tmp/.scanimages
					;;
				rootfs)
					mkdir -p .ubit/rootfs
					echo .ubit $prt 32 >> /tmp/.scanimages
					;;
				*)
					echo .ubit $prt 32 >> /tmp/.scanimages
					echo $prt >> /.ubit.ubimounts
					;;
					esac
				[ "$suffix" ] && if [ "$backup" ]; then 
					rename="$rename ${prt} ${prt}${backup} ${prt}${suffix} ${prt}"
				else
					rename="$rename ${prt}${suffix} ${prt}"
					fi
				done

			# this odd twist sets the ramdisk contents after the scan has completed but before the writes begin
			mkdir -p .ubit/ramdisk
			cat /cpio_list | cpio -H newc -o | gzip > /tmp/initramfs.cpio.gz
			mkimage -A arm -O linux -T ramdisk -C gzip -a 0x0 -e 0x0 -n 'Installed UBIT ramdisk' -d /tmp/initramfs.cpio.gz .ubit/ramdisk/uInitrd

			[ "$rename" ] && echo $rename > /.ubit.rename
	
			orange_slow
			# now we write all the images
			cat /tmp/.scanimages | while read pth prt lebcnt; do
				( cd $pth
					ubimg $lebcnt
					)
				done
			break
		fi

		done 
	orange_normal



